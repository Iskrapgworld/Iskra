<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ò–°–ö–†–ê: –®–∞—Ö—Ç–∞</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
    }
    h1 { color: #ffaa00; }
    #board {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 4px;
      width: 360px;
      margin: 20px auto;
    }
    .cell {
      width: 58px; height: 58px;
      border-radius: 50%;
      transition: transform 0.3s, opacity 0.6s ease;
    }
    .red    { background: radial-gradient(circle, #ff4d4d, #990000); }
    .green  { background: radial-gradient(circle, #66ff66, #006600); }
    .blue   { background: radial-gradient(circle, #66ccff, #003366); }
    .orange { background: radial-gradient(circle, #ffcc66, #cc6600); }
    .purple { background: radial-gradient(circle, #cc99ff, #440066); }
    .highlight { box-shadow: 0 0 10px 4px #fff8; }
    .fade { opacity: 0; }
    #log { margin: 10px auto; min-height: 20px; font-size: 14px; color: #ccc; }
    #rockHP { font-size: 18px; margin-top: 10px; }
    button {
      padding: 8px 16px;
      background: #5522aa;
      color: white;
      border: none;
      border-radius: 8px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>‚õèÔ∏è –®–∞—Ö—Ç–∞ –ò—Å–∫—Ä—ã</h1>
  <div id="rockHP">–ü–ª–∞—Å—Ç —à–∞—Ö—Ç—ã: 300 ‚ù§Ô∏è</div>
  <div id="board"></div>
  <div id="log">–°–æ–±–µ—Ä–∏ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã, —á—Ç–æ–±—ã –¥–æ–±—ã—Ç—å —Ä—É–¥—É!</div>
  <button onclick="restartMine()">–°–ª–µ–¥—É—é—â–∏–π –ø–ª–∞—Å—Ç</button>

  <script>
    const board = document.getElementById("board");
    const log = document.getElementById("log");
    const hpBar = document.getElementById("rockHP");

    const colors = ['red', 'green', 'blue', 'orange', 'purple'];
    let grid = [], dragging = null;
    let rockHP = 300;

    function index(r, c) {
      return r * 6 + c;
    }

    function getColor(el) {
      return colors.find(c => el.classList.contains(c));
    }

    function restartMine() {
      rockHP = 300;
      hpBar.textContent = `–ü–ª–∞—Å—Ç —à–∞—Ö—Ç—ã: ${rockHP} ‚ù§Ô∏è`;
      log.textContent = "–ù–æ–≤—ã–π –ø–ª–∞—Å—Ç –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–¥–æ–ª–∂–∞–π –∫–æ–ø–∞—Ç—å!";
      createGridWithoutMatches();
    }

    function createGridWithoutMatches() {
      board.innerHTML = "";
      grid = [];
      let tries = 0;
      do {
        board.innerHTML = "";
        grid = [];
        for (let i = 0; i < 36; i++) {
          const cell = document.createElement("div");
          cell.className = "cell " + colors[Math.floor(Math.random() * colors.length)];
          board.appendChild(cell);
          grid.push(cell);
        }
        tries++;
        if (tries > 100) break;
      } while (checkMatches().length > 0);
    }

    function checkMatches() {
      const matches = [];
      for (let r = 0; r < 6; r++) {
        for (let c = 0; c < 4; c++) {
          let i = index(r, c);
          let a = grid[i], b = grid[i + 1], c_ = grid[i + 2];
          if (getColor(a) === getColor(b) && getColor(b) === getColor(c_))
            matches.push([i, i + 1, i + 2]);
        }
      }
      for (let c = 0; c < 6; c++) {
        for (let r = 0; r < 4; r++) {
          let i = index(r, c);
          let a = grid[i], b = grid[i + 6], c_ = grid[i + 12];
          if (getColor(a) === getColor(b) && getColor(b) === getColor(c_))
            matches.push([i, i + 6, i + 12]);
        }
      }
      return matches;
    }

    function resolveCascade() {
      const matches = checkMatches();
      if (matches.length === 0) return;

      let comboCount = 0;
      let redTotal = 0;

      matches.forEach(g => {
        const color = getColor(grid[g[0]]);
        if (color === "red") redTotal += g.length;
        comboCount++;
        g.forEach(i => grid[i].classList.add("highlight"));
      });

      setTimeout(() => {
        matches.flat().forEach(i => {
          grid[i].classList.remove("highlight");
          grid[i].classList.add("fade");
        });

        setTimeout(() => {
          matches.flat().forEach(i => grid[i].className = "cell");
          dropDown();
          applyDamage(redTotal, comboCount);
          setTimeout(resolveCascade, 600);
        }, 600);
      }, 800);
    }

    function applyDamage(redCount, combos) {
      let dmg = redCount >= 5 ? 20 : redCount >= 3 ? 10 : 0;
      let bonus = Math.floor(combos * 0.05 * dmg);
      let total = dmg + bonus;
      if (total > 0) {
        rockHP -= total;
        if (rockHP < 0) rockHP = 0;
        hpBar.textContent = `–ü–ª–∞—Å—Ç —à–∞—Ö—Ç—ã: ${rockHP} ‚ù§Ô∏è`;
        log.textContent = `–¢—ã –ø—Ä–æ–±–∏–ª –ø–ª–∞—Å—Ç –Ω–∞ ${total} —É—Ä–æ–Ω–∞! (${combos} –∫–æ–º–±–æ)`;
        if (rockHP === 0) {
          log.textContent = `üí• –ü–ª–∞—Å—Ç —Ä–∞–∑—Ä—É—à–µ–Ω! –ù–∞–π–¥–µ–Ω–∞ —Ä—É–¥–∞. –ñ–º–∏ "–°–ª–µ–¥—É—é—â–∏–π –ø–ª–∞—Å—Ç".`;
        }
      } else {
        log.textContent = `–ù–µ—Ç —É—Ä–æ–Ω–∞ –ø–æ –ø–ª–∞—Å—Ç—É. –ù—É–∂–Ω–æ –±–æ–ª—å—à–µ –∫—Ä–∞—Å–Ω—ã—Ö!`;
      }
    }

    function dropDown() {
      for (let c = 0; c < 6; c++) {
        for (let r = 5; r > 0; r--) {
          let i = index(r, c);
          if (!getColor(grid[i])) {
            for (let k = r - 1; k >= 0; k--) {
              let up = index(k, c);
              if (getColor(grid[up])) {
                grid[i].className = grid[up].className;
                grid[up].className = "cell";
                break;
              }
            }
          }
        }
        for (let r = 0; r < 6; r++) {
          let i = index(r, c);
          if (!getColor(grid[i])) {
            const cls = colors[Math.floor(Math.random() * colors.length)];
            grid[i].className = "cell " + cls;
          }
        }
      }
    }

    board.addEventListener("touchstart", e => {
      const t = e.touches[0];
      const el = document.elementFromPoint(t.clientX, t.clientY);
      if (el && el.classList.contains("cell")) dragging = el;
    });
    board.addEventListener("touchmove", e => {
      if (!dragging) return;
      const t = e.touches[0];
      const el = document.elementFromPoint(t.clientX, t.clientY);
      if (el && el.classList.contains("cell") && el !== dragging) {
        [dragging.className, el.className] = [el.className, dragging.className];
        dragging = el;
      }
    });
    board.addEventListener("touchend", () => {
      dragging = null;
      resolveCascade();
    });

    createGridWithoutMatches();
  </script>
</body>
</html>
