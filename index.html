<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ò–°–ö–†–ê: –ë–∏—Ç–≤–∞</title>
  <style>
    body {
      margin: 0;
      background: #000;
      font-family: sans-serif;
      color: #fff;
      text-align: center;
      background-image: url('https://i.imgur.com/ZGuYHhb.png'); /* –§–æ–Ω */
      background-size: cover;
      background-position: center;
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      image-rendering: pixelated;
      border: 2px solid orange;
    }
    #status {
      margin-top: 10px;
      font-size: 20px;
    }
  </style>
</head>
<body>
  <h2>üî• –ò–°–ö–†–ê: PvP-–ö—Ä–∏—Å—Ç–∞–ª–ª—ã üî•</h2>
  <div id="status">–ò–≥—Ä–æ–∫ 1: 1000 ‚ù§Ô∏è ‚Äî –ò–≥—Ä–æ–∫ 2: 1000 ‚ù§Ô∏è</div>
  <canvas id="gameCanvas" width="360" height="360"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const size = 6;
    const tileSize = 60;
    const colors = ["#f00", "#0f0", "#00f", "#f0f", "#ffa500", "#fff"]; // + –±–∞–∑–æ–≤–∞—è –ø–∞–ª–∏—Ç—Ä–∞
    const types = ["attack", "heal", "shield", "mana", "crit", "blank"];

    let board = [];
    let dragging = null;
    let turn = 1;
    let hp1 = 1000;
    let hp2 = 1000;

    function initBoard() {
      board = [];
      for (let y = 0; y < size; y++) {
        let row = [];
        for (let x = 0; x < size; x++) {
          row.push({
            type: types[Math.floor(Math.random() * 5)],
            fading: false,
            fadeTime: 0
          });
        }
        board.push(row);
      }
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          const color = getColor(cell.type);
          if (cell.fading) {
            ctx.globalAlpha = 1 - cell.fadeTime / 1000;
          } else {
            ctx.globalAlpha = 1;
          }
          ctx.fillStyle = color;
          ctx.beginPath();
          if (cell.type === "attack") {
            ctx.moveTo(x * tileSize + 30, y * tileSize);
            ctx.lineTo(x * tileSize + 60, y * tileSize + 30);
            ctx.lineTo(x * tileSize + 30, y * tileSize + 60);
            ctx.lineTo(x * tileSize, y * tileSize + 30);
          } else if (cell.type === "heal") {
            ctx.fillRect(x * tileSize + 20, y * tileSize + 25, 20, 10);
            ctx.fillRect(x * tileSize + 25, y * tileSize + 20, 10, 20);
            continue;
          } else if (cell.type === "shield") {
            ctx.arc(x * tileSize + 30, y * tileSize + 30, 25, 0, Math.PI * 2);
          } else {
            ctx.rect(x * tileSize + 5, y * tileSize + 5, 50, 50);
          }
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
    }

    function getColor(type) {
      switch (type) {
        case "attack": return "#f00";
        case "heal": return "#0f0";
        case "shield": return "#00f";
        case "mana": return "#f0f";
        case "crit": return "#ffa500";
        default: return "#888";
      }
    }

    canvas.addEventListener("mousedown", (e) => {
      const x = Math.floor(e.offsetX / tileSize);
      const y = Math.floor(e.offsetY / tileSize);
      dragging = {x, y, started: true};
      lostMove = false;
    });

    canvas.addEventListener("mouseup", () => {
      if (dragging) {
        if (dragging.started) {
          lostMove = true; // –æ—Ç–ø—É—Å—Ç–∏–ª —Ä–∞–Ω—å—à–µ
        } else {
          checkCombos();
        }
      }
      dragging = null;
    });

    function checkCombos() {
      let combos = [];
      for (let y = 0; y < size; y++) {
        let streak = 1;
        for (let x = 1; x < size; x++) {
          if (board[y][x].type === board[y][x-1].type) {
            streak++;
          } else {
            if (streak >= 3) combos.push({row: y, start: x - streak, end: x - 1, type: board[y][x-1].type});
            streak = 1;
          }
        }
        if (streak >= 3) combos.push({row: y, start: size - streak, end: size - 1, type: board[y][size-1].type});
      }

      if (combos.length > 0) {
        for (let c of combos) {
          for (let x = c.start; x <= c.end; x++) {
            board[c.row][x].fading = true;
            board[c.row][x].fadeTime = 0;
          }
        }

        setTimeout(() => {
          for (let c of combos) {
            for (let x = c.start; x <= c.end; x++) {
              applyEffect(c.type, c.end - c.start + 1);
              board[c.row][x] = {
                type: types[Math.floor(Math.random() * 5)],
                fading: false,
                fadeTime: 0
              };
            }
          }
          drawBoard();
          updateStatus();
        }, 2000);
      }
    }

    function applyEffect(type, count) {
      let value = (count >= 5) ? 20 : 10;
      if (type === "attack") {
        if (turn === 1) hp2 -= value;
        else hp1 -= value;
      } else if (type === "heal") {
        if (turn === 1) hp1 += value;
        else hp2 += value;
      }
    }

    function updateStatus() {
      document.getElementById("status").innerText = `–ò–≥—Ä–æ–∫ 1: ${hp1} ‚ù§Ô∏è ‚Äî –ò–≥—Ä–æ–∫ 2: ${hp2} ‚ù§Ô∏è`;
      if (hp1 <= 0 || hp2 <= 0) {
        setTimeout(() => {
          alert(hp1 <= 0 ? "–ü–æ–±–µ–¥–∏–ª –ò–≥—Ä–æ–∫ 2!" : "–ü–æ–±–µ–¥–∏–ª –ò–≥—Ä–æ–∫ 1!");
          initBoard();
          hp1 = 1000;
          hp2 = 1000;
          updateStatus();
          drawBoard();
        }, 500);
      }
    }

    initBoard();
    drawBoard();
    updateStatus();
  </script>
</body>
</html>
