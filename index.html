<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–®–∞—Ö—Ç–∞ –ò—Å–∫—Ä—ã</title>
  <style>
    body {
      margin: 0;
      background-color: #1a1a1a;
      color: #eee;
      font-family: sans-serif;
      text-align: center;
    }
    h1 {
      margin: 10px 0;
      color: #ffcc00;
    }
    #hud {
      display: flex;
      justify-content: space-around;
      padding: 10px;
      background: #111;
      font-size: 14px;
    }
    #inventory {
      display: flex;
      justify-content: space-around;
      padding: 10px;
      background: #222;
      font-size: 14px;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 4px;
      width: 360px;
      margin: 20px auto;
    }
    .cell {
      width: 58px;
      height: 58px;
      border-radius: 50%;
    }
    .red    { background: radial-gradient(circle, #ff4d4d, #990000); }
    .purple { background: radial-gradient(circle, #cc99ff, #5500aa); }
    .orange { background: radial-gradient(circle, #ffbb66, #cc6600); }
    .yellow { background: radial-gradient(circle, #ffff66, #ccaa00); }
    .fade { opacity: 0.2; }
  </style>
</head>
<body>
  <h1>‚öíÔ∏è –®–∞—Ö—Ç–∞ –ò—Å–∫—Ä—ã</h1>
  <div id="hud">
    <div>üîã –ò—Å–∫—Ä–∞: <span id="spark">1000</span></div>
    <div>‚õèÔ∏è –ì–ª—É–±–∏–Ω–∞: <span id="depth">0</span></div>
  </div>
  <div id="inventory">
    <div>ü™® –ú–µ—Ç–∞–ª–ª: <span id="metal">0</span></div>
    <div>üíé –ö—Ä–∏—Å—Ç–∞–ª–ª—ã: <span id="crystal">0</span></div>
    <div>ü™ô –ó–æ–ª–æ—Ç–æ: <span id="gold">0</span></div>
  </div>
  <div id="board"></div>

  <script>
    const board = document.getElementById("board");
    const sparkEl = document.getElementById("spark");
    const depthEl = document.getElementById("depth");
    const metalEl = document.getElementById("metal");
    const crystalEl = document.getElementById("crystal");
    const goldEl = document.getElementById("gold");

    let spark = 1000, depth = 0, metal = 0, crystal = 0, gold = 0;
    const colors = ['red', 'purple', 'orange', 'yellow'];
    let grid = [], dragging = null;

    function updateHUD() {
      sparkEl.textContent = spark;
      depthEl.textContent = depth;
      metalEl.textContent = metal;
      crystalEl.textContent = crystal;
      goldEl.textContent = gold;
    }

    function createGrid() {
      board.innerHTML = "";
      grid = [];
      for (let i = 0; i < 36; i++) {
        const cell = document.createElement("div");
        cell.className = "cell " + colors[Math.floor(Math.random() * colors.length)];
        board.appendChild(cell);
        grid.push(cell);
      }
    }

    function getColor(el) {
      return colors.find(c => el.classList.contains(c));
    }

    function checkMatches() {
      const matches = [];
      for (let r = 0; r < 6; r++) {
        for (let c = 0; c < 4; c++) {
          let i = r * 6 + c;
          let a = grid[i], b = grid[i + 1], c_ = grid[i + 2];
          if (getColor(a) === getColor(b) && getColor(b) === getColor(c_))
            matches.push([i, i + 1, i + 2]);
        }
      }
      for (let c = 0; c < 6; c++) {
        for (let r = 0; r < 4; r++) {
          let i = r * 6 + c;
          let a = grid[i], b = grid[i + 6], c_ = grid[i + 12];
          if (getColor(a) === getColor(b) && getColor(b) === getColor(c_))
            matches.push([i, i + 6, i + 12]);
        }
      }
      return matches;
    }

    function applyEffects(combo) {
      let type = getColor(grid[combo[0]]);
      let length = combo.length;

      if (type === 'red') metal += length;
      if (type === 'purple' || type === 'orange') crystal += length;
      if (type === 'yellow') {
        gold += Math.floor(Math.random() * length);
      }
    }

    function resolveTurn() {
      if (spark < 5) return alert("–ù–µ—Ç –∏—Å–∫—Ä—ã!");

      spark -= 5;
      depth += 1;

      const matches = checkMatches();
      if (matches.length === 0) return;

      matches.forEach(g => {
        applyEffects(g);
        g.forEach(i => {
          grid[i].classList.add("fade");
        });
      });

      setTimeout(() => {
        matches.flat().forEach(i => {
          const newColor = colors[Math.floor(Math.random() * colors.length)];
          grid[i].className = "cell " + newColor;
        });
        updateHUD();
      }, 500);
    }

    board.addEventListener("touchstart", e => {
      const t = e.touches[0];
      const el = document.elementFromPoint(t.clientX, t.clientY);
      if (el && el.classList.contains("cell")) dragging = el;
    });

    board.addEventListener("touchmove", e => {
      if (!dragging) return;
      const t = e.touches[0];
      const el = document.elementFromPoint(t.clientX, t.clientY);
      if (el && el.classList.contains("cell") && el !== dragging) {
        [dragging.className, el.className] = [el.className, dragging.className];
        dragging = el;
      }
    });

    board.addEventListener("touchend", () => {
      dragging = null;
      resolveTurn();
    });

    createGrid();
    updateHUD();
  </script>
</body>
</html>
