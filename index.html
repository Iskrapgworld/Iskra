<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ò–°–ö–†–ê: –®–∞—Ö—Ç–∞</title>
  <style>
    body {
      margin: 0;
      background-color: #111;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
    }
    h1 {
      color: #ffcc00;
      margin-top: 10px;
    }
    #topBar {
      display: flex;
      justify-content: space-around;
      margin: 10px;
      font-size: 14px;
    }
    .stat {
      line-height: 1.6;
    }
    .bar {
      height: 12px;
      background: #333;
      border-radius: 6px;
      overflow: hidden;
      margin-top: 3px;
    }
    .bar-inner {
      height: 100%;
      transition: width 0.3s ease;
    }
    #spark { color: #ffff66; }
    #board {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 4px;
      width: 360px;
      margin: 10px auto;
    }
    .cell {
      width: 58px;
      height: 58px;
      border-radius: 50%;
      transition: transform 0.3s ease;
    }
    .red    { background: radial-gradient(circle, #ff4d4d, #990000); }
    .green  { background: radial-gradient(circle, #66ff66, #006600); }
    .blue   { background: radial-gradient(circle, #66ccff, #003366); }
    .orange { background: radial-gradient(circle, #ffaa00, #993300); }
    .purple { background: radial-gradient(circle, #cc99ff, #330066); }
    .highlight { box-shadow: 0 0 8px 4px #fff5; }
    .fade { opacity: 0; }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      background: #444;
      color: #fff;
      border: none;
      border-radius: 10px;
    }
    #result {
      font-size: 14px;
      margin-top: 10px;
      min-height: 20px;
    }
    #depth {
      font-size: 16px;
      margin-bottom: 5px;
      color: #aaa;
    }
    #timerBarContainer {
      width: 300px;
      height: 10px;
      background: #333;
      margin: 0 auto;
      border-radius: 5px;
      overflow: hidden;
    }
    #timerBar {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #33ff33, #ffff00);
      transition: width 1s linear;
    }
  </style>
</head>
<body>
  <h1>‚õè –®–∞—Ö—Ç–∞ –ò—Å–∫—Ä—ã</h1>
  <div id="depth">–ì–ª—É–±–∏–Ω–∞: 0 –º (1 —É—Ä–æ–≤–µ–Ω—å)</div>
  <div id="topBar">
    <div class="stat">
      ‚ö° –ò—Å–∫—Ä–∞: <span id="spark">1000</span>
    </div>
    <div class="stat">
      üí® –í–æ–∑–¥—É—Ö
      <div class="bar"><div id="airBar" class="bar-inner" style="width:100%;background:#00ffcc;"></div></div>
    </div>
    <div class="stat">
      üß± –°–≤–æ–¥
      <div class="bar"><div id="roofBar" class="bar-inner" style="width:100%;background:#3399ff;"></div></div>
    </div>
  </div>
  <div id="timerBarContainer"><div id="timerBar"></div></div>
  <div id="board"></div>
  <button onclick="startMiningTurn()">üîÅ –°–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥ (-5 –ò—Å–∫—Ä—ã)</button>
  <div id="result"></div>

  <script>
    const colors = ['red', 'green', 'blue', 'orange', 'purple'];
    const board = document.getElementById("board");
    const sparkEl = document.getElementById("spark");
    const airBar = document.getElementById("airBar");
    const roofBar = document.getElementById("roofBar");
    const result = document.getElementById("result");
    const depthText = document.getElementById("depth");
    const timerBar = document.getElementById("timerBar");

    let spark = 1000;
    let dragging = null;
    let grid = [];
    let depth = 0;
    let air = 100;
    let roof = 100;
    let timer = 10;
    let timerInterval, airInterval;
    let level = 1;

    const layerHealth = {1: 100, 2: 150, 3: 300};
    const layerLoot = {
      1: {stone: 50, gold: 20, crystal: 5},
      2: {stone: 70, gold: 30, crystal: 10},
      3: {stone: 90, gold: 50, crystal: 20}
    };

    function createBoard() {
      board.innerHTML = "";
      grid = [];
      for (let i = 0; i < 36; i++) {
        const color = colors[Math.floor(Math.random() * colors.length)];
        const cell = document.createElement("div");
        cell.className = "cell " + color;
        board.appendChild(cell);
        grid.push(cell);
      }
    }

    function index(r, c) {
      return r * 6 + c;
    }

    function getColor(el) {
      return colors.find(c => el.classList.contains(c));
    }

    function startMiningTurn() {
      if (spark < 5) {
        alert("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ò—Å–∫—Ä—ã!");
        return;
      }
      spark -= 5;
      sparkEl.textContent = spark;
      timer = 10;
      timerBar.style.width = "100%";
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timer--;
        timerBar.style.width = (timer * 10) + "%";
        if (timer <= 0) {
          clearInterval(timerInterval);
          resolveCascade();
        }
      }, 1000);
    }

    function startAirDrain() {
      airInterval = setInterval(() => {
        air -= 100 / 30; // 30 —Å–µ–∫ ‚Äî 100%
        if (air <= 0) {
          air = 0;
          clearInterval(airInterval);
          result.textContent = "‚ùå –ö–æ–Ω—á–∏–ª—Å—è –≤–æ–∑–¥—É—Ö!";
        }
        airBar.style.width = air + "%";
      }, 1000);
    }

    function checkMatches() {
      const matches = [];
      for (let r = 0; r < 6; r++) {
        for (let c = 0; c < 4; c++) {
          let i = index(r, c);
          let a = grid[i], b = grid[i+1], c_ = grid[i+2];
          if (getColor(a) === getColor(b) && getColor(b) === getColor(c_))
            matches.push([i, i+1, i+2]);
        }
      }
      for (let c = 0; c < 6; c++) {
        for (let r = 0; r < 4; r++) {
          let i = index(r, c);
          let a = grid[i], b = grid[i+6], c_ = grid[i+12];
          if (getColor(a) === getColor(b) && getColor(b) === getColor(c_))
            matches.push([i, i+6, i+12]);
        }
      }
      return matches;
    }

    function resolveCascade() {
      const matches = checkMatches();
      const tally = { red: 0, green: 0, blue: 0, orange: 0, purple: 0 };
      if (matches.length === 0) {
        result.textContent = "–ö–æ–º–±–∏–Ω–∞—Ü–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ";
        return;
      }

      matches.forEach(g => {
        const color = getColor(grid[g[0]]);
        tally[color] += g.length;
        g.forEach(i => grid[i].classList.add("highlight"));
      });

      setTimeout(() => {
        matches.flat().forEach(i => {
          grid[i].classList.remove("highlight");
          grid[i].classList.add("fade");
        });
        setTimeout(() => {
          matches.flat().forEach(i => {
            const newColor = colors[Math.floor(Math.random() * colors.length)];
            grid[i].className = "cell " + newColor;
            grid[i].classList.remove("fade");
          });
          applyMiningEffects(tally, matches.length);
        }, 500);
      }, 800);
    }

    function applyMiningEffects(tally, comboCount) {
      let airGain = 0;
      if (tally.green >= 3) airGain = 10 + (tally.green - 3) * 2;
      air += airGain;
      if (air > 100) air = 100;

      roof -= 10; // —Ä—É—à–∏—Ç—Å—è –±—ã—Å—Ç—Ä–µ–µ
      if (tally.blue >= 3) roof += 10;
      if (roof > 100) roof = 100;
      if (roof < 0) roof = 0;

      let healthMax = layerHealth[level];
      let damage = (tally.red >= 5 ? 20 : tally.red >= 3 ? 10 : 0);
      let comboBonus = Math.floor(comboCount * 0.05 * damage);
      let total = damage + comboBonus;
      let percent = Math.floor((total / healthMax) * 100);

      depth += percent;
      if (depth >= level * 100) {
        level++;
        depth = 0;
        result.textContent = `üåü –î–æ—Å—Ç–∏–≥–Ω—É—Ç –Ω–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å —à–∞—Ö—Ç—ã: ${level}`;
      } else {
        // –¥–æ–±—ã—á–∞
        let loot = "";
        const chance = Math.random() * 100;
        const lootTable = layerLoot[level] || {stone: 100, gold: 0, crystal: 0};
        if (chance < lootTable.crystal) loot = "üíé –ö—Ä–∏—Å—Ç–∞–ª–ª";
        else if (chance < lootTable.gold) loot = "ü•á –ó–æ–ª–æ—Ç–æ";
        else loot = "ü™® –ñ–µ–ª–µ–∑–æ";

        result.textContent = `‚õè –†–∞—Å–∫–æ–ø–∞–Ω–æ: ${percent}% ‚Äî –ù–∞–π–¥–µ–Ω–æ: ${loot}`;
      }

      depthText.textContent = `–ì–ª—É–±–∏–Ω–∞: ${depth} –º (${level} —É—Ä–æ–≤–µ–Ω—å)`;
      airBar.style.width = air + "%";
      roofBar.style.width = roof + "%";
      sparkEl.textContent = spark;

      if (roof <= 0) {
        result.textContent = "‚ùå –û–±–≤–∞–ª! –®–∞—Ö—Ç–∞ —Ä–∞–∑—Ä—É—à–µ–Ω–∞!";
        clearInterval(airInterval);
      }
    }

    board.addEventListener("touchstart", e => {
      const t = e.touches[0];
      const el = document.elementFromPoint(t.clientX, t.clientY);
      if (el && el.classList.contains("cell")) dragging = el;
    });
    board.addEventListener("touchmove", e => {
      if (!dragging) return;
      const t = e.touches[0];
      const el = document.elementFromPoint(t.clientX, t.clientY);
      if (el && el.classList.contains("cell") && el !== dragging) {
        [dragging.className, el.className] = [el.className, dragging.className];
        dragging = el;
      }
    });
    board.addEventListener("touchend", () => {
      dragging = null;
    });

    createBoard();
    startAirDrain();
  </script>
</body>
</html>
