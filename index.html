<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ò–°–ö–†–ê: –£–ª—É—á—à–µ–Ω–Ω–∞—è –ë–∏—Ç–≤–∞</title>
  <style>
    body {
      margin: 0;
      background-color: #111;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
    }
    h1 {
      color: #ffa500;
      margin: 10px 0;
      text-shadow: 0 0 10px #ff6600;
    }
    #topBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 10px;
      font-size: 14px;
      background: #222;
      border-radius: 10px;
      margin: 5px;
    }
    #timerBarContainer {
      flex-grow: 1;
      height: 10px;
      margin: 0 10px;
      background: #444;
      border-radius: 5px;
      overflow: hidden;
    }
    #timerBar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #33ff33, #ffff00);
      transition: width 1s linear;
    }
    #battleLog {
      margin: 5px;
      padding: 10px;
      font-size: 14px;
      min-height: 40px;
      background: #222;
      border-radius: 10px;
      border-left: 3px solid #ffa500;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 4px;
      width: 360px;
      margin: 30px auto 10px auto;
      transition: opacity 0.3s ease;
    }
    .cell {
      width: 58px;
      height: 58px;
      border-radius: 50%;
      transition: transform 0.3s ease, opacity 1s ease;
      position: relative;
      overflow: hidden;
    }
    .cell::after {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .cell:hover::after {
      opacity: 0.3;
    }
    .red    { background: radial-gradient(circle, #ff4d4d, #990000); }
    .green  { background: radial-gradient(circle, #66ff66, #006600); }
    .blue   { background: radial-gradient(circle, #66ccff, #003366); }
    .purple { background: radial-gradient(circle, #dca0ff, #440066); }
    .orange { background: radial-gradient(circle, #cc9955, #cc6600); }
    .highlight { 
      box-shadow: 0 0 15px 5px #ffffffaa;
      transform: scale(1.1);
    }
    .fade { opacity: 0; }
    .enemy-turn #board {
      pointer-events: none;
      opacity: 0.5;
    }
    #overlay, #endScreen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 999;
    }
    .floatText {
      position: absolute;
      font-size: 14px;
      font-weight: bold;
      pointer-events: none;
      animation: floatUp 1s ease forwards;
      z-index: 100;
    }
    @keyframes floatUp {
      from { opacity: 1; transform: translateY(0); }
      to   { opacity: 0; transform: translateY(-30px); }
    }
    #overlay input {
      padding: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: none;
      margin-top: 10px;
      width: 200px;
      text-align: center;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      background: #6622cc;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
    }
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 10px #8844ff;
    }
    #lightningButton {
      background: linear-gradient(#ffcc00, #ff9900);
      color: #000;
      font-weight: bold;
    }
    #shieldButton {
      background: linear-gradient(#3399ff, #0066cc);
      font-weight: bold;
    }
    .combo-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 28px;
      font-weight: bold;
      color: gold;
      text-shadow: 0 0 10px #000, 0 0 20px #ff6600;
      opacity: 0;
      transition: all 0.3s;
      pointer-events: none;
      z-index: 1000;
    }
    .combo-show {
      opacity: 1;
      transform: translate(-50%, -60%);
    }
    @keyframes attack {
      0% { transform: translateX(0); }
      25% { transform: translateX(20px); }
      50% { transform: translateX(-20px); }
      100% { transform: translateX(0); }
    }
    .attack-animation {
      animation: attack 0.3s linear;
    }
    #stats {
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 10px;
      margin-top: 10px;
    }
    .ability-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 10px;
    }
  </style>
</head>
<body>
  <h1>üî• –ò–°–ö–†–ê: –£–ª—É—á—à–µ–Ω–Ω–∞—è –ë–∏—Ç–≤–∞ üî•</h1>
  <div id="topBar">
    <div>–í—ã:<br>‚ù§Ô∏è <span id="hp">200</span>/200<br>üõ° <span id="shield">100</span>/100<br>üîÆ <span id="mana">0</span>/100</div>
    <div id="timerBarContainer"><div id="timerBar"></div></div>
    <div>–ú–æ–Ω—Å—Ç—Ä:<br>üíÄ <span id="enemyHp">500</span>/500<br>üõ° <span id="enemyShield">300</span>/300<br>üîÆ <span id="enemyMana">0</span>/100</div>
  </div>
  <div id="battleLog">–°–æ–±–µ—Ä–∏—Ç–µ 3 –∏–ª–∏ –±–æ–ª–µ–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö —à–∞—Ä–∞ –≤ —Ä—è–¥!</div>
  <div id="board"></div>
  <div class="ability-container">
    <button id="lightningButton" onclick="useLightning()">‚ö° –ú–æ–ª–Ω–∏—è (20)</button>
    <button id="shieldButton" onclick="useShield()">üõ° –©–∏—Ç (30)</button>
  </div>
  <div id="overlay">
    <h2>–í–≤–µ–¥–∏—Ç–µ –∏–º—è –≤–æ–∏–Ω–∞:</h2>
    <input id="nickname" placeholder="–í–∞—à–µ –∏–º—è" maxlength="12">
    <button onclick="startGame()">–ù–∞—á–∞—Ç—å –±–∏—Ç–≤—É!</button>
  </div>
  <div id="endScreen" style="display:none;">
    <h2 id="endMessage">–ü–æ–±–µ–¥–∞!</h2>
    <div id="stats">
      –£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span><br>
      –ü–æ–±–µ–¥—ã: <span id="wins">0</span>
    </div>
    <button onclick="startGame()">–°—Ä–∞–∑–∏—Ç—å—Å—è —Å–Ω–æ–≤–∞</button>
  </div>
  <script>
const CONFIG = {
  player: {
    maxHp: 200,
    maxShield: 100,
    maxMana: 100
  },
  monster: {
    maxHp: 500,
    maxShield: 300,
    maxMana: 100
  },
  comboEffects: {
    small: 3,
    big: 5,
    damage: [0, 15, 25],
    heal: [0, 8, 15],
    shield: [0, 8, 15],
    crit: 2,
    mana: [0, 15, 25]
  },
  abilities: {
    lightning: {
      cost: 20,
      damage: 50
    },
    shield: {
      cost: 30,
      amount: 50
    }
  },
  colors: ['red', 'green', 'blue', 'purple', 'orange'],
  turnTime: 20
};

const board = document.getElementById("board");
const hpEl = document.getElementById("hp");
const shieldEl = document.getElementById("shield");
const enemyHpEl = document.getElementById("enemyHp");
const enemyShieldEl = document.getElementById("enemyShield");
const timerBar = document.getElementById("timerBar");
const overlay = document.getElementById("overlay");
const endScreen = document.getElementById("endScreen");
const endMessage = document.getElementById("endMessage");
const battleLog = document.getElementById("battleLog");
const manaEl = document.getElementById("mana");
const enemyManaEl = document.getElementById("enemyMana");
const lightningBtn = document.getElementById("lightningButton");
const shieldBtn = document.getElementById("shieldButton");
const levelEl = document.getElementById("level");
const winsEl = document.getElementById("wins");

let grid = [], dragging = null;
let isPlayerTurn = true;
let hp = CONFIG.player.maxHp;
let shield = CONFIG.player.maxShield;
let mana = 0;
let enemyHp = CONFIG.monster.maxHp;
let enemyShield = CONFIG.monster.maxShield;
let enemyMana = 0;
let playerName = "–ò–≥—Ä–æ–∫";
let turnTimer;
let comboAccumulator = {};
let level = 1, wins = 0;

function startGame() {
  playerName = document.getElementById("nickname").value || "–í–æ–∏–Ω";
  hp = CONFIG.player.maxHp;
  shield = CONFIG.player.maxShield;
  mana = 0;
  enemyHp = CONFIG.monster.maxHp * (1 + (level-1)*0.2);
  enemyShield = CONFIG.monster.maxShield * (1 + (level-1)*0.1);
  enemyMana = 0;
  
  updateStats();
  createGrid();
  overlay.style.display = "none";
  endScreen.style.display = "none";
  document.body.classList.remove("enemy-turn");
  isPlayerTurn = true;
  updateAbilityButtons();
  startTurn();
}

function updateStats() {
  hpEl.textContent = Math.max(0, Math.floor(hp));
  shieldEl.textContent = Math.max(0, Math.floor(shield));
  manaEl.textContent = Math.max(0, Math.floor(mana));
  enemyHpEl.textContent = Math.max(0, Math.floor(enemyHp));
  enemyShieldEl.textContent = Math.max(0, Math.floor(enemyShield));
  enemyManaEl.textContent = Math.max(0, Math.floor(enemyMana));
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  hpEl.parentElement.innerHTML = `–í—ã:<br>‚ù§Ô∏è <span id="hp">${Math.floor(hp)}</span>/${CONFIG.player.maxHp}<br>üõ° <span id="shield">${Math.floor(shield)}</span>/${CONFIG.player.maxShield}<br>üîÆ <span id="mana">${Math.floor(mana)}</span>/${CONFIG.player.maxMana}`;
  enemyHpEl.parentElement.innerHTML = `–ú–æ–Ω—Å—Ç—Ä:<br>üíÄ <span id="enemyHp">${Math.floor(enemyHp)}</span>/${Math.floor(CONFIG.monster.maxHp * (1 + (level-1)*0.2))}<br>üõ° <span id="enemyShield">${Math.floor(enemyShield)}</span>/${Math.floor(CONFIG.monster.maxShield * (1 + (level-1)*0.1))}<br>üîÆ <span id="enemyMana">${Math.floor(enemyMana)}</span>/${CONFIG.monster.maxMana}`;
  
  // –ü–µ—Ä–µ–ø—Ä–∏–≤—è–∑—ã–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è HTML
  hpEl = document.getElementById("hp");
  shieldEl = document.getElementById("shield");
  manaEl = document.getElementById("mana");
  enemyHpEl = document.getElementById("enemyHp");
  enemyShieldEl = document.getElementById("enemyShield");
  enemyManaEl = document.getElementById("enemyMana");
}

function updateAbilityButtons() {
  lightningBtn.style.display = mana >= CONFIG.abilities.lightning.cost ? "inline-block" : "none";
  shieldBtn.style.display = mana >= CONFIG.abilities.shield.cost ? "inline-block" : "none";
}

function createGrid() {
  board.innerHTML = "";
  grid = [];
  for (let i = 0; i < 36; i++) {
    const cell = document.createElement("div");
    const color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
    cell.className = `cell ${color}`;
    cell.dataset.color = color;
    board.appendChild(cell);
    grid.push(cell);
  }
}

function index(r, c) {
  return r * 6 + c;
}

function getColor(el) {
  return el ? el.dataset.color : null;
}

function startTurn() {
  isPlayerTurn = true;
  comboAccumulator = { 
    red: 0, green: 0, blue: 0, orange: 0, purple: 0, 
    count: 0, total: 0 
  };
  document.body.classList.remove("enemy-turn");
  board.style.pointerEvents = "auto";
  updateAbilityButtons();

  let time = CONFIG.turnTime;
  timerBar.style.width = "100%";
  timerBar.style.background = "linear-gradient(90deg, #33ff33, #ffff00)";
  clearInterval(turnTimer);
  turnTimer = setInterval(() => {
    time--;
    timerBar.style.width = (time * 100 / CONFIG.turnTime) + "%";
    if (time <= CONFIG.turnTime/3) {
      timerBar.style.background = "linear-gradient(90deg, #ffff00, #ff3333)";
    }
    if (time <= 0) {
      clearInterval(turnTimer);
      board.style.pointerEvents = "none";
      resolveCascade();
    }
  }, 1000);
}

function resolveCascade() {
  const matches = checkMatches();
  if (matches.length === 0) {
    applyEffects();
    if (checkEnd()) return;
    isPlayerTurn ? setTimeout(monsterTurn, 1000) : setTimeout(startTurn, 1000);
    return;
  }

  // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
  matches.forEach(group => {
    const color = getColor(grid[group[0]]);
    comboAccumulator[color] = (comboAccumulator[color] || 0) + group.length;
    comboAccumulator.count += 1;
    comboAccumulator.total += group.length;
    
    group.forEach(i => {
      grid[i].classList.add("highlight");
      grid[i].style.transform = "scale(1.1)";
    });
  });

  setTimeout(() => {
    // –£–¥–∞–ª–µ–Ω–∏–µ –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –∏ –∞–Ω–∏–º–∞—Ü–∏—è –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
    matches.flat().forEach(i => {
      grid[i].classList.remove("highlight");
      grid[i].classList.add("fade");
      grid[i].style.transform = "scale(0)";
    });
    
    setTimeout(() => {
      // –£–¥–∞–ª–µ–Ω–∏–µ —à–∞—Ä–æ–≤ –∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—É—Å—Ç–æ—Ç
      matches.flat().forEach(i => {
        grid[i].className = "cell";
        grid[i].style.transform = "";
        grid[i].dataset.color = "";
      });
      dropDown();
      setTimeout(resolveCascade, 600);
    }, 600);
  }, 1000);
}

function applyEffects() {
  const { red, green, blue, orange, purple, count, total } = comboAccumulator;
  
  // –†–∞—Å—á–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
  const effects = {
    damage: red >= CONFIG.comboEffects.big ? CONFIG.comboEffects.damage[2] : 
            red >= CONFIG.comboEffects.small ? CONFIG.comboEffects.damage[1] : 0,
    heal: green >= CONFIG.comboEffects.big ? CONFIG.comboEffects.heal[2] : 
          green >= CONFIG.comboEffects.small ? CONFIG.comboEffects.heal[1] : 0,
    shield: blue >= CONFIG.comboEffects.big ? CONFIG.comboEffects.shield[2] : 
            blue >= CONFIG.comboEffects.small ? CONFIG.comboEffects.shield[1] : 0,
    critChance: orange * CONFIG.comboEffects.crit,
    mana: purple >= CONFIG.comboEffects.big ? CONFIG.comboEffects.mana[2] : 
          purple >= CONFIG.comboEffects.small ? CONFIG.comboEffects.mana[1] : 0
  };

  // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–±–æ
  if (count > 0) showComboEffect(count, total);

  if (isPlayerTurn) {
    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –¥–ª—è –∏–≥—Ä–æ–∫–∞
    mana += effects.mana;
    if (mana > CONFIG.player.maxMana) mana = CONFIG.player.maxMana;
    
    let isCrit = Math.random() * 100 < effects.critChance;
    let totalDmg = effects.damage * (isCrit ? 2 : 1);
    
    // –£—Ä–æ–Ω –æ—Ç –º–æ–ª–Ω–∏–∏ –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞
    if (lightningUsed) {
      totalDmg += CONFIG.abilities.lightning.damage;
      lightningUsed = false;
    }

    // –ê–Ω–∏–º–∞—Ü–∏—è –∞—Ç–∞–∫–∏
    animateAttack(enemyHpEl.parentElement, true);
    
    // –†–∞—Å—á–µ—Ç —É—Ä–æ–Ω–∞ —Å —É—á–µ—Ç–æ–º —â–∏—Ç–∞
    applyDamage(totalDmg, false);
    
    // –õ–µ—á–µ–Ω–∏–µ –∏ –∑–∞—â–∏—Ç–∞
    if (effects.heal > 0) {
      hp += effects.heal;
      if (hp > CONFIG.player.maxHp) hp = CONFIG.player.maxHp;
      float(`+${effects.heal}`, hpEl, "#00ff00");
    }
    
    if (effects.shield > 0) {
      shield += effects.shield;
      if (shield > CONFIG.player.maxShield) shield = CONFIG.player.maxShield;
      float(`+${effects.shield}`, shieldEl, "#3399ff");
    }

    // –õ–æ–≥ –±–∏—Ç–≤—ã
    let logMsg = `<span style="color:#66ff66">–ö–æ–º–±–æ √ó${count} (${total} —à–∞—Ä–æ–≤): `;
    if (effects.damage > 0) logMsg += `–£—Ä–æ–Ω: ${effects.damage}${isCrit ? ' (–ö–†–ò–¢!)' : ''}`;
    if (lightningUsed) logMsg += ` +${CONFIG.abilities.lightning.damage} –æ—Ç –º–æ–ª–Ω–∏–∏`;
    if (effects.heal > 0) logMsg += `, –õ–µ—á–µ–Ω–∏–µ: +${effects.heal}`;
    if (effects.shield > 0) logMsg += `, –ó–∞—â–∏—Ç–∞: +${effects.shield}`;
    if (effects.mana > 0) logMsg += `, –ú–∞–Ω–∞: +${effects.mana}`;
    battleLog.innerHTML = logMsg + "</span>";

  } else {
    // –≠—Ñ—Ñ–µ–∫—Ç—ã –¥–ª—è –º–æ–Ω—Å—Ç—Ä–∞
    enemyMana += effects.mana;
    if (enemyMana > CONFIG.monster.maxMana) enemyMana = CONFIG.monster.maxMana;
    
    let isCrit = Math.random() * 100 < effects.critChance;
    let totalDmg = effects.damage * (isCrit ? 2 : 1);

    // –ê–Ω–∏–º–∞—Ü–∏—è –∞—Ç–∞–∫–∏
    animateAttack(hpEl.parentElement, false);
    
    // –†–∞—Å—á–µ—Ç —É—Ä–æ–Ω–∞
    applyDamage(totalDmg, true);
    
    // –õ–µ—á–µ–Ω–∏–µ –∏ –∑–∞—â–∏—Ç–∞ –º–æ–Ω—Å—Ç—Ä–∞
    if (effects.heal > 0) {
      enemyHp += effects.heal;
      if (enemyHp > CONFIG.monster.maxHp * (1 + (level-1)*0.2)) {
        enemyHp = CONFIG.monster.maxHp * (1 + (level-1)*0.2);
      }
      float(`+${effects.heal}`, enemyHpEl, "#00ff00");
    }
    
    if (effects.shield > 0) {
      enemyShield += effects.shield;
      if (enemyShield > CONFIG.monster.maxShield * (1 + (level-1)*0.1)) {
        enemyShield = CONFIG.monster.maxShield * (1 + (level-1)*0.1);
      }
      float(`+${effects.shield}`, enemyShieldEl, "#3399ff");
    }

    // –õ–æ–≥ –±–∏—Ç–≤—ã
    battleLog.innerHTML = `<span style="color:#ff4444">–ö–æ–º–±–æ –º–æ–Ω—Å—Ç—Ä–∞ √ó${count}: –£—Ä–æ–Ω: ${effects.damage}${isCrit ? ' (–ö–†–ò–¢!)' : ''}${effects.heal > 0 ? ', –õ–µ—á–µ–Ω–∏–µ: +' + effects.heal : ''}${effects.shield > 0 ? ', –ó–∞—â–∏—Ç–∞: +' + effects.shield : ''}</span>`;
  }

  updateStats();
  updateAbilityButtons();
}

function applyDamage(damage, toPlayer) {
  if (toPlayer) {
    let half = Math.floor(damage / 2);
    if (shield >= half) {
      shield -= half;
      hp -= (damage - half);
    } else {
      let rem = half - shield;
      shield = 0;
      hp -= (damage - half + rem);
    }
    float(`-${damage}`, hpEl, "#ff0000");
  } else {
    let half = Math.floor(damage / 2);
    if (enemyShield >= half) {
      enemyShield -= half;
      enemyHp -= (damage - half);
    } else {
      let rem = half - enemyShield;
      enemyShield = 0;
      enemyHp -= (damage - half + rem);
    }
    float(`-${damage}`, enemyHpEl, "#ff0000");
  }
}

function useLightning() {
  if (mana >= CONFIG.abilities.lightning.cost && isPlayerTurn) {
    mana -= CONFIG.abilities.lightning.cost;
    lightningUsed = true;
    updateStats();
    updateAbilityButtons();
    battleLog.innerHTML += `<br><span style="color:#ffff00">‚ö° –ú–æ–ª–Ω–∏—è –≥–æ—Ç–æ–≤–∞ –∫ —É–¥–∞—Ä—É!</span>`;
  }
}

function useShield() {
  if (mana >= CONFIG.abilities.shield.cost && isPlayerTurn) {
    mana -= CONFIG.abilities.shield.cost;
    shield += CONFIG.abilities.shield.amount;
    if (shield > CONFIG.player.maxShield) shield = CONFIG.player.maxShield;
    updateStats();
    updateAbilityButtons();
    float(`+${CONFIG.abilities.shield.amount}`, shieldEl, "#3399ff");
    battleLog.innerHTML += `<br><span style="color:#3399ff">üõ° –©–∏—Ç —É—Å–∏–ª–µ–Ω!</span>`;
  }
}

function showComboEffect(count, total) {
  const comboEl = document.createElement('div');
  comboEl.className = 'combo-display';
  
  let comboText = `COMBO x${count}!`;
  if (total >= 10) comboText = `SUPER ${comboText}`;
  if (total >= 15) comboText = `MEGA ${comboText}`;
  
  comboEl.textContent = comboText;
  document.body.appendChild(comboEl);
  
  setTimeout(() => comboEl.classList.add('combo-show'), 10);
  setTimeout(() => {
    comboEl.classList.remove('combo-show');
    setTimeout(() => comboEl.remove(), 300);
  }, 1500);
}

function animateAttack(target, isPlayer) {
  target.classList.add('attack-animation');
  setTimeout(() => target.classList.remove('attack-animation'), 300);
  
  // –≠—Ñ—Ñ–µ–∫—Ç –≤—Å–ø—ã—à–∫–∏
  const flash = document.createElement('div');
  const rect = target.getBoundingClientRect();
  flash.style.position = 'fixed';
  flash.style.background = isPlayer ? 'radial-gradient(circle, rgba(255,100,100,0.7), transparent)' : 'radial-gradient(circle, rgba(100,100,255,0.7), transparent)';
  flash.style.borderRadius = '50%';
  flash.style.width = (rect.width * 2) + 'px';
  flash.style.height = (rect.height * 2) + 'px';
  flash.style.left = (rect.left - rect.width/2) + 'px';
  flash.style.top = (rect.top - rect.height/2) + 'px';
  flash.style.pointerEvents = 'none';
  flash.style.zIndex = '99';
  flash.style.opacity = '0';
  flash.style.transition = 'opacity 0.5s';
  
  document.body.appendChild(flash);
  setTimeout(() => flash.style.opacity = '1', 10);
  setTimeout(() => {
    flash.style.opacity = '0';
    setTimeout(() => flash.remove(), 500);
  }, 300);
}

function checkEnd() {
  if (hp <= 0) {
    endMessage.textContent = "–ü–æ—Ä–∞–∂–µ–Ω–∏–µ!";
    endScreen.style.display = "flex";
    return true;
  }
  if (enemyHp <= 0) {
    wins++;
    if (wins % 3 === 0) level++;
    levelEl.textContent = level;
    winsEl.textContent = wins;
    endMessage.textContent = `–ü–æ–±–µ–¥–∞, ${playerName}!`;
    endScreen.style.display = "flex";
    return true;
  }
  return false;
}

function dropDown() {
  for (let c = 0; c < 6; c++) {
    // –ü–∞–¥–µ–Ω–∏–µ —à–∞—Ä–æ–≤ –≤–Ω–∏–∑
    for (let r = 5; r >= 0; r--) {
      const i = index(r, c);
      if (!getColor(grid[i])) {
        // –ò—â–µ–º –ø–µ—Ä–≤—ã–π —à–∞—Ä –≤—ã—à–µ
        for (let k = r - 1; k >= 0; k--) {
          const up = index(k, c);
          if (getColor(grid[up])) {
            grid[i].className = grid[up].className;
            grid[i].dataset.color = grid[up].dataset.color;
            grid[up].className = "cell";
            grid[up].dataset.color = "";
            break;
          }
        }
      }
    }
    
    // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—É—Å—Ç—ã—Ö –º–µ—Å—Ç –Ω–æ–≤—ã–º–∏ —à–∞—Ä–∞–º–∏
    for (let r = 0; r < 6; r++) {
      const i = index(r, c);
      if (!getColor(grid[i])) {
    
