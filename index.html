
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ò–°–ö–†–ê: –ë–∏—Ç–≤–∞</title>
  <style>
    body { background: #1e1e1e; color: #fff; font-family: sans-serif; text-align: center; margin: 0; }
    h1 { color: #ffcc66; margin: 20px 0; }
    #scoreboard { display: flex; justify-content: space-around; margin-bottom: 10px; }
    #timerBar { width: 80%; height: 10px; background: #555; margin: 10px auto; border-radius: 5px; overflow: hidden; }
    #timerProgress { height: 100%; background: #ffcc66; width: 100%; transition: width 0.1s; }
    #board { display: grid; grid-template-columns: repeat(6, 1fr); gap: 2px; width: 360px; margin: 0 auto; }
    .cell { width: 58px; height: 58px; border-radius: 50%; touch-action: none; transition: transform 0.2s, opacity 2s ease; }
    .red { background: radial-gradient(circle, #ff5e5e, #8b0000); }
    .green { background: radial-gradient(circle, #7fff7f, #228b22); }
    .blue { background: linear-gradient(135deg, #66ccff, #003366); }
    .yellow { background: radial-gradient(circle, #ffff88, #ffaa00); }
    .purple { background: radial-gradient(circle, #dca0ff, #440066); }
    .orange { background: radial-gradient(circle, #ffc266, #cc6600); }
    .fade { opacity: 0; }
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%;
               background: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column;
               justify-content: center; align-items: center; z-index: 2; }
    #overlay button { padding: 10px 20px; background: #6622cc; border: none;
                      color: #fff; font-size: 18px; border-radius: 10px; margin-top: 20px; }
    #damageInfo { font-size: 16px; color: #88f; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>üî• –ò–°–ö–†–ê: –ë–∏—Ç–≤–∞ üî•</h1>
  <div id="scoreboard">
    <div>–ò–≥—Ä–æ–∫ 1: <span id="hp1">200</span> ‚ù§Ô∏è <span id="shield1">150</span> üõ°</div>
    <div>–ò–≥—Ä–æ–∫ 2: <span id="hp2">200</span> ‚ù§Ô∏è <span id="shield2">150</span> üõ°</div>
  </div>
  <div id="timerBar"><div id="timerProgress"></div></div>
  <div id="board"></div>
  <div id="overlay">
    <div id="turnInfo">–•–æ–¥ –∏–≥—Ä–æ–∫–∞ 1</div>
    <div id="damageInfo"></div>
    <button id="startBtn">–ù–∞—á–∞—Ç—å —Ö–æ–¥</button>
  </div>
  <script>
    const colorClasses = ['red','green','blue','orange','purple','yellow'];
    const board = document.getElementById('board');
    const hp1El = document.getElementById('hp1');
    const hp2El = document.getElementById('hp2');
    const shield1El = document.getElementById('shield1');
    const shield2El = document.getElementById('shield2');
    const overlay = document.getElementById('overlay');
    const turnInfo = document.getElementById('turnInfo');
    const damageInfo = document.getElementById('damageInfo');
    const startBtn = document.getElementById('startBtn');
    const timerProgress = document.getElementById('timerProgress');

    let grid = [], currentPlayer = 1;
    let dragging = null, turnActive = false, timer, timeLeft;
    let hp = {1: 200, 2: 200}, shield = {1: 150, 2: 150}, critChance = {1: 10, 2: 10};

    function index(r,c){return r*6 + c}
    function createGrid(){
      board.innerHTML = ''; grid = []
      for(let i=0;i<36;i++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.classList.add(colorClasses[Math.floor(Math.random()*colorClasses.length)])
        board.appendChild(cell);
        grid.push(cell);
      }
    }
    function getColorClass(el){ return colorClasses.find(cls => el.classList.contains(cls)) }
    function checkMatches(){
      const matched = []
      for(let r=0;r<6;r++){
        for(let c=0;c<4;c++){
          let i = index(r,c)
          let a=grid[i], b=grid[i+1], c_=grid[i+2]
          if(getColorClass(a)===getColorClass(b)&&getColorClass(b)===getColorClass(c_))
            matched.push([i,i+1,i+2])
        }
      }
      for(let c=0;c<6;c++){
        for(let r=0;r<4;r++){
          let i=index(r,c)
          let a=grid[i],b=grid[i+6],c_=grid[i+12]
          if(getColorClass(a)===getColorClass(b)&&getColorClass(b)===getColorClass(c_))
            matched.push([i,i+6,i+12])
        }
      }
      return matched
    }
    function removeMatches(matches,callback){
      matches.flat().forEach(i=>grid[i].classList.add('fade'))
      setTimeout(()=>{
        matches.flat().forEach(i=>grid[i].className='cell')
        dropDown(); setTimeout(callback,300)
      },2000)
    }
    function dropDown(){
      for(let c=0;c<6;c++){
        for(let r=5;r>0;r--){
          let i=index(r,c)
          if(!getColorClass(grid[i])){
            for(let k=r-1;k>=0;k--){
              let up=index(k,c)
              if(getColorClass(grid[up])){
                grid[i].className=grid[up].className
                grid[up].className='cell'; break
              }
            }
          }
        }
        for(let r=0;r<6;r++){
          let i=index(r,c)
          if(!getColorClass(grid[i])){
            let cls=colorClasses[Math.floor(Math.random()*colorClasses.length)]
            grid[i].className='cell '+cls
          }
        }
      }
    }
    function startTurn(){
      turnActive=true; timeLeft=200
      timer=setInterval(()=>{
        timeLeft--;
        timerProgress.style.width=(timeLeft/200*100)+'%'
        if(timeLeft<=0){ clearInterval(timer); finishTurn() }
      },50)
    }
    function finishTurn(){
      turnActive=false
      let matches = checkMatches(), counts = { red:0, green:0, blue:0, orange:0, purple:0 }
      matches.forEach(group=>{
        let color=getColorClass(grid[group[0]])
        if(counts[color]!==undefined) counts[color] += group.length
      })
      function cascade(){
        matches=checkMatches()
        if(matches.length>0){
          matches.forEach(group=>{
            let color=getColorClass(grid[group[0]])
            if(counts[color]!==undefined) counts[color]+=group.length
          })
          removeMatches(matches, cascade)
        }else{ applyEffects(counts) }
      }
      cascade()
    }
    function applyEffects(counts){
      let crit=critChance[currentPlayer]
      if(counts.orange>=6) crit+=25
      else if(counts.orange>=5) crit+=20
      else if(counts.orange>=3) crit+=10
      let roll=Math.random()*100<crit, critText=roll?"–ö—Ä–∏—Ç! ":""
      if(roll) critChance[currentPlayer]=10
      else critChance[currentPlayer]=crit
      let dmg=0, heal=0, shieldGain=0
      const attackStones = counts.red + counts.purple
      if(attackStones>=6) dmg=20
      else if(attackStones>=5) dmg=15
      else if(attackStones>=3) dmg=10
      if(roll) dmg*=2
      if(counts.green>=5) heal=10
      else if(counts.green>=3) heal=5
      if(counts.blue>=6) shieldGain=12
      else if(counts.blue>=5) shieldGain=10
      else if(counts.blue>=3) shieldGain=5
      const target = currentPlayer===1 ? 2 : 1
      if(shield[target]>=dmg){ shield[target]-=dmg }
      else{ let remain=dmg-shield[target]; shield[target]=0; hp[target]-=remain }
      shield[currentPlayer]+=shieldGain
      if(shield[currentPlayer]>150) shield[currentPlayer]=150
      hp[currentPlayer]+=heal
      if(hp[currentPlayer]>200) hp[currentPlayer]=200
      hp1El.textContent=hp[1]; hp2El.textContent=hp[2]
      shield1El.textContent=shield[1]; shield2El.textContent=shield[2]
      damageInfo.innerHTML = `${critText}–£—Ä–æ–Ω: ${dmg}<br>–õ–µ—á–µ–Ω–∏–µ: ${heal}<br>–©–∏—Ç—ã: +${shieldGain}<br>–ö—Ä–∏—Ç. —à–∞–Ω—Å: ${critChance[currentPlayer]}%`
      if(hp[1]<=0||hp[2]<=0){
        turnInfo.textContent=`–ü–æ–±–µ–¥–∞ –∏–≥—Ä–æ–∫–∞ ${hp[1]<=0?2:1}!`
        startBtn.textContent="–ù–æ–≤–∞—è –∏–≥—Ä–∞"
      }else{
        currentPlayer = target
        turnInfo.textContent=`–•–æ–¥ –∏–≥—Ä–æ–∫–∞ ${currentPlayer}`
        startBtn.textContent="–ù–∞—á–∞—Ç—å —Ö–æ–¥"
      }
      overlay.style.display="flex"
    }
    board.addEventListener("touchstart",e=>{
      if(!turnActive)return
      const t=e.touches[0]
      const el=document.elementFromPoint(t.clientX,t.clientY)
      if(el && el.classList.contains("cell")) dragging=el
    })
    board.addEventListener("touchmove",e=>{
      if(!dragging)return
      const t=e.touches[0]
      const el=document.elementFromPoint(t.clientX,t.clientY)
      if(el && el.classList.contains("cell") && el!==dragging){
        let tmp=dragging.className
        dragging.className=el.className
        el.className=tmp; dragging=el
      }
    })
    board.addEventListener("touchend",()=>{
      if(turnActive){ turnActive=false; clearInterval(timer); finishTurn() }
    })
    startBtn.onclick=()=>{
      if(startBtn.textContent==="–ù–æ–≤–∞—è –∏–≥—Ä–∞"){
        hp={1:200,2:200}; shield={1:150,2:150}; critChance={1:10,2:10}
        hp1El.textContent=hp[1]; hp2El.textContent=hp[2]
        shield1El.textContent=shield[1]; shield2El.textContent=shield[2]
        createGrid(); damageInfo.textContent=""
        turnInfo.textContent="–•–æ–¥ –∏–≥—Ä–æ–∫–∞ 1"; startBtn.textContent="–ù–∞—á–∞—Ç—å —Ö–æ–¥"
      }
      overlay.style.display="none"; startTurn()
    }
    createGrid(); overlay.style.display="flex"
  </script>
</body>
</html>
