<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üî•–ò–°–ö–†–ê: PvP-–ö—Ä–∏—Å—Ç–∞–ª–ª—ãüî•</title>
  <style>
    html, body {
      margin: 0;
      background: #111;
      font-family: sans-serif;
      color: #f7c76f;
      text-align: center;
    }
    .top-bar {
      padding: 10px;
      font-size: 20px;
      background: #000;
    }
    .hp {
      display: flex;
      justify-content: space-around;
      font-size: 16px;
    }
    canvas {
      margin-top: 5px;
      display: block;
      margin-left: auto;
      margin-right: auto;
      touch-action: none;
      image-rendering: pixelated;
    }
    .timer {
      height: 8px;
      background: #f7c76f;
      transition: width 0.2s linear;
    }
  </style>
</head>
<body>
  <div class="top-bar">üî• –ò–°–ö–†–ê: PvP-–ö—Ä–∏—Å—Ç–∞–ª–ª—ã üî•</div>
  <div class="hp">
    <div id="hp1">–ò–≥—Ä–æ–∫ 1: 1000 ‚ù§Ô∏è</div>
    <div id="hp2">–ò–≥—Ä–æ–∫ 2: 1000 ‚ù§Ô∏è</div>
  </div>
  <div class="timer" id="turnBar" style="width:100%"></div>
  <canvas id="game" width="360" height="360"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const size = 6, cell = 60;
    const types = ['red','blue','green','orange','purple','yellow'];
    const shapes = {
      red: pts => { ctx.moveTo(...pts[0]); pts.slice(1).forEach(p => ctx.lineTo(...p)); ctx.closePath(); }, // –æ—Å—Ç—Ä–∞—è
      blue: pts => { ctx.arc(pts[0][0], pts[0][1], 22, 0, 2*Math.PI); }, // –∫—Ä—É–≥–ª–∞—è
      green: pts => { ctx.moveTo(...pts[0]); ctx.lineTo(...pts[1]); ctx.lineTo(...pts[2]); ctx.lineTo(...pts[3]); ctx.closePath(); }, // –∫—Ä–µ—Å—Ç
      orange: pts => { ctx.arc(pts[0][0], pts[0][1], 22, 0, 2*Math.PI); },
      purple: pts => { ctx.arc(pts[0][0], pts[0][1], 22, 0, 2*Math.PI); },
      yellow: pts => { ctx.arc(pts[0][0], pts[0][1], 22, 0, 2*Math.PI); },
    };
    const colors = {
      red: '#ff4d4d',
      blue: '#4da6ff',
      green: '#4dff4d',
      orange: '#ffaa00',
      purple: '#cc66ff',
      yellow: '#ffff4d',
    };
    let board = [];
    let selected = null, animating = false;
    let currentPlayer = 1;
    let hp = [1000, 1000];
    let turnTimer;
    let bar = document.getElementById("turnBar");

    function randomType() {
      return types[Math.floor(Math.random() * types.length)];
    }

    function initBoard() {
      board = [];
      for (let y = 0; y < size; y++) {
        let row = [];
        for (let x = 0; x < size; x++) {
          row.push({type: randomType(), x, y, alpha: 1});
        }
        board.push(row);
      }
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          let cellData = board[y][x];
          if (!cellData) continue;
          ctx.globalAlpha = cellData.alpha ?? 1;
          ctx.beginPath();
          ctx.fillStyle = colors[cellData.type];
          const cx = x * cell + cell / 2;
          const cy = y * cell + cell / 2;
          if (cellData.type === 'green') {
            shapes.green([[cx-10, cy], [cx+10, cy], [cx+10, cy+10], [cx-10, cy+10]]);
          } else if (cellData.type in shapes) {
            shapes[cellData.type]([[cx, cy]]);
          }
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
    }

    function swap(a,b) {
      const temp = board[a.y][a.x];
      board[a.y][a.x] = board[b.y][b.x];
      board[b.y][b.x] = temp;
      [a.x, b.x] = [b.x, a.x];
      [a.y, b.y] = [b.y, a.y];
    }

    function checkMatches() {
      let matches = [];
      for (let y = 0; y < size; y++) {
        let run = [board[y][0]];
        for (let x = 1; x < size; x++) {
          if (board[y][x].type === run[0].type) {
            run.push(board[y][x]);
          } else {
            if (run.length >= 3) matches.push([...run]);
            run = [board[y][x]];
          }
        }
        if (run.length >= 3) matches.push([...run]);
      }

      for (let x = 0; x < size; x++) {
        let run = [board[0][x]];
        for (let y = 1; y < size; y++) {
          if (board[y][x].type === run[0].type) {
            run.push(board[y][x]);
          } else {
            if (run.length >= 3) matches.push([...run]);
            run = [board[y][x]];
          }
        }
        if (run.length >= 3) matches.push([...run]);
      }
      return matches;
    }

    function applyMatches(matches) {
      let damage = 0, heal = 0;
      for (const match of matches) {
        for (const tile of match) {
          tile.alpha = 1;
        }
        let base = match[0].type;
        let val = match.length >= 5 ? 20 : 10;
        if (base === 'red') damage += val;
        if (base === 'green') heal += val;
      }

      setTimeout(() => {
        for (const match of matches) {
          for (const tile of match) {
            board[tile.y][tile.x] = null;
          }
        }
        dropTiles();
        updateHP(damage, heal);
      }, 2000); // –ø–æ—Å–ª–µ –ø–æ–¥—Å–≤–µ—Ç–∫–∏
    }

    function dropTiles() {
      for (let x = 0; x < size; x++) {
        for (let y = size-1; y >= 0; y--) {
          if (board[y][x] == null) {
            for (let k = y-1; k >= 0; k--) {
              if (board[k][x] != null) {
                board[y][x] = board[k][x];
                board[k][x] = null;
                board[y][x].y = y;
                break;
              }
            }
          }
        }
        for (let y = 0; y < size; y++) {
          if (board[y][x] == null) {
            board[y][x] = {type: randomType(), x, y, alpha: 1};
          }
        }
      }
      drawBoard();
      let more = checkMatches();
      if (more.length) applyMatches(more);
      else endTurn();
    }

    function updateHP(dmg, heal) {
      let enemy = 1 - (currentPlayer - 1);
      hp[enemy] -= dmg;
      hp[currentPlayer-1] += heal;
      if (hp[enemy] < 0) hp[enemy] = 0;
      document.getElementById('hp1').innerText = `–ò–≥—Ä–æ–∫ 1: ${hp[0]} ‚ù§Ô∏è`;
      document.getElementById('hp2').innerText = `–ò–≥—Ä–æ–∫ 2: ${hp[1]} ‚ù§Ô∏è`;
    }

    function endTurn() {
      currentPlayer = 3 - currentPlayer;
      startTurn();
    }

    function startTurn() {
      let timeLeft = 20;
      bar.style.width = "100%";
      turnTimer = setInterval(() => {
        timeLeft--;
        bar.style.width = (timeLeft * 5) + "%";
        if (timeLeft <= 0) {
          clearInterval(turnTimer);
          endTurn();
        }
      }, 1000);
    }

    canvas.addEventListener('pointerdown', e => {
      if (animating) return;
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cell);
      const y = Math.floor((e.clientY - rect.top) / cell);
      selected = board[y][x];
    });

    canvas.addEventListener('pointerup', e => {
      if (!selected) return;
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cell);
      const y = Math.floor((e.clientY - rect.top) / cell);
      const target = board[y][x];
      if (selected && target && ((Math.abs(selected.x - target.x) + Math.abs(selected.y - target.y)) === 1)) {
        swap(selected, target);
        const matches = checkMatches();
        if (matches.length > 0) {
          animating = true;
          clearInterval(turnTimer);
          applyMatches(matches);
        } else {
          swap(selected, target);
        }
      }
      selected = null;
    });

    initBoard();
    drawBoard();
    startTurn();
  </script>
</body>
</html>
