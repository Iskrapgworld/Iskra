<script>
let grid = [], hp = {1: 1000, 2: 1000}, currentPlayer = 1, gameMode = 'pvp';
let dragging = null, turnActive = false, timer, timeLeft;
const board = document.getElementById('board');
const hp1El = document.getElementById('hp1');
const hp2El = document.getElementById('hp2');
const overlay = document.getElementById('overlay');
const turnInfo = document.getElementById('turnInfo');
const damageInfo = document.getElementById('damageInfo');
const startBtn = document.getElementById('startBtn');
const timerProgress = document.getElementById('timerProgress');
const scoreboard = document.getElementById('scoreboard');
const colorClasses = ['red', 'blue', 'green', 'yellow', 'purple'];

function startGame(mode) {
  gameMode = mode;
  document.getElementById('modeSelect').style.display = 'none';
  scoreboard.style.display = 'flex';
  createGrid();
  overlay.style.display = 'flex';
  turnInfo.textContent = 'Ход игрока 1';
  damageInfo.textContent = '';
}

function createGrid() {
  board.innerHTML = ''; grid = [];
  for (let i = 0; i < 36; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    let cls = colorClasses[Math.floor(Math.random() * colorClasses.length)];
    cell.classList.add(cls);
    board.appendChild(cell);
    grid.push(cell);
  }
}

function getColorClass(el) {
  return colorClasses.find(cls => el.classList.contains(cls));
}

function index(r, c) { return r * 6 + c; }

function checkMatches() {
  const matched = [];
  for (let r = 0; r < 6; r++) {
    for (let c = 0; c < 4; c++) {
      let i = index(r, c);
      let a = grid[i], b = grid[i + 1], c_ = grid[i + 2];
      if (getColorClass(a) === getColorClass(b) && getColorClass(b) === getColorClass(c_)) {
        matched.push([i, i + 1, i + 2]);
      }
    }
  }
  for (let c = 0; c < 6; c++) {
    for (let r = 0; r < 4; r++) {
      let i = index(r, c);
      let a = grid[i], b = grid[i + 6], c_ = grid[i + 12];
      if (getColorClass(a) === getColorClass(b) && getColorClass(b) === getColorClass(c_)) {
        matched.push([i, i + 6, i + 12]);
      }
    }
  }
  return matched;
}

function removeMatches(matches, callback) {
  matches.flat().forEach(i => grid[i].classList.add('fade'));
  setTimeout(() => {
    matches.flat().forEach(i => grid[i].className = 'cell');
    dropDown();
    setTimeout(callback, 300);
  }, 2000);
}

function dropDown() {
  for (let c = 0; c < 6; c++) {
    for (let r = 5; r > 0; r--) {
      let i = index(r, c);
      if (!getColorClass(grid[i])) {
        for (let k = r - 1; k >= 0; k--) {
          let up = index(k, c);
          if (getColorClass(grid[up])) {
            grid[i].className = grid[up].className;
            grid[up].className = 'cell';
            break;
          }
        }
      }
    }
    for (let r = 0; r < 6; r++) {
      let i = index(r, c);
      if (!getColorClass(grid[i])) {
        let cls = colorClasses[Math.floor(Math.random() * colorClasses.length)];
        grid[i].className = 'cell ' + cls;
      }
    }
  }
}

function beginTurn() {
  overlay.style.display = 'none';
  turnActive = true; timeLeft = 200;
  timer = setInterval(() => {
    timeLeft--;
    timerProgress.style.width = (timeLeft / 200 * 100) + "%";
    if (timeLeft <= 0) {
      clearInterval(timer);
      finishTurn();
    }
  }, 50);
}

function finishTurn() {
  turnActive = false;
  let matches = checkMatches();
  let redCount = 0, greenCount = 0;
  matches.forEach(group => {
    let color = getColorClass(grid[group[0]]);
    if (color === 'red') redCount += group.length;
    if (color === 'green') greenCount += group.length;
  });

  function cascade() {
    matches = checkMatches();
    if (matches.length > 0) {
      matches.forEach(group => {
        let color = getColorClass(grid[group[0]]);
        if (color === 'red') redCount += group.length;
        if (color === 'green') greenCount += group.length;
      });
      removeMatches(matches, cascade);
    } else {
      applyEffects(redCount, greenCount);
    }
  }
  cascade();
}

function applyEffects(red, green) {
  let dmg = 0, heal = 0;
  if (red >= 5) dmg = 20;
  else if (red >= 3) dmg = 10;
  if (green >= 5) heal = 20;
  else if (green >= 3) heal = 10;
  let target = currentPlayer === 1 ? 2 : 1;
  hp[target] -= dmg;
  if (hp[target] < 0) hp[target] = 0;
  hp[currentPlayer] += heal;
  if (hp[currentPlayer] > 1000) hp[currentPlayer] = 1000;
  hp1El.textContent = hp[1];
  hp2El.textContent = hp[2];
  damageInfo.innerHTML = `${dmg ? `Урон: ${dmg}` : ''} ${heal ? `Лечение: ${heal}` : ''}`.trim();
  if (hp[1] === 0 || hp[2] === 0) {
    turnInfo.textContent = `Победа игрока ${hp[1] === 0 ? 2 : 1}!`;
    startBtn.textContent = 'Новая игра';
  } else {
    currentPlayer = target;
    turnInfo.textContent = `Ход игрока ${currentPlayer}`;
    startBtn.textContent = 'Начать ход';
  }
  overlay.style.display = 'flex';
  if (gameMode === 'pve' && currentPlayer === 2 && hp[2] > 0) {
    setTimeout(enemyTurn, 1000);
  }
}

function enemyTurn() {
  // Простой бот: случайно выбирает и меняет 2 соседних элемента
  const i = Math.floor(Math.random() * 35);
  const neighbor = i % 6 < 5 ? i + 1 : i - 1;
  const a = grid[i], b = grid[neighbor];
  let tmp = a.className;
  setTimeout(() => {
    a.className = b.className;
    b.className = tmp;
    finishTurn();
  }, 5000);
}

board.addEventListener('touchstart', e => {
  if (!turnActive) return;
  const t = e.touches[0];
  const el = document.elementFromPoint(t.clientX, t.clientY);
  if (el && el.classList.contains('cell')) dragging = el;
});

board.addEventListener('touchmove', e => {
  if (!dragging) return;
  const t = e.touches[0];
  const el = document.elementFromPoint(t.clientX, t.clientY);
  if (el && el.classList.contains('cell') && el !== dragging) {
    let tmp = dragging.className;
    dragging.className = el.className;
    el.className = tmp;
    dragging = el;
  }
});

board.addEventListener('touchend', () => {
  if (turnActive) {
    turnActive = false;
    clearInterval(timer);
    finishTurn();
  }
});
</script>
