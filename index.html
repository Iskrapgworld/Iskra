<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–ò–°–ö–†–ê: –ë–∏—Ç–≤–∞</title>
  <style>
    body {
      margin: 0;
      background-color: #111;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
    }
    h1 {
      color: #ffa500;
      margin: 10px 0;
      text-shadow: 0 0 10px #ff6600;
    }
    #topBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 10px;
      font-size: 14px;
      background: #222;
      border-radius: 10px;
      margin: 5px;
    }
    #timerBarContainer {
      flex-grow: 1;
      height: 10px;
      margin: 0 10px;
      background: #444;
      border-radius: 5px;
      overflow: hidden;
    }
    #timerBar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #33ff33, #ffff00);
      transition: width 1s linear;
    }
    #battleLog {
      margin: 5px;
      padding: 10px;
      font-size: 14px;
      min-height: 40px;
      background: #222;
      border-radius: 10px;
      border-left: 3px solid #ffa500;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 4px;
      width: 360px;
      margin: 30px auto 10px auto;
      transition: opacity 0.3s ease;
    }
    .cell {
      width: 58px;
      height: 58px;
      border-radius: 50%;
      transition: transform 0.3s ease, opacity 1s ease;
      position: relative;
      overflow: hidden;
    }
    .cell::after {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .cell:hover::after {
      opacity: 0.3;
    }
    .red { background: radial-gradient(circle, #ff4d4d, #990000); }
    .green { background: radial-gradient(circle, #66ff66, #006600); }
    .blue { background: radial-gradient(circle, #66ccff, #003366); }
    .purple { background: radial-gradient(circle, #dca0ff, #440066); }
    .orange { background: radial-gradient(circle, #cc9955, #cc6600); }
    .highlight { 
      box-shadow: 0 0 15px 5px #ffffffaa;
      transform: scale(1.1);
    }
    .fade { opacity: 0; }
    .enemy-turn #board {
      pointer-events: none;
      opacity: 0.5;
    }
    #overlay, #endScreen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 999;
    }
    .floatText {
      position: absolute;
      font-size: 14px;
      font-weight: bold;
      pointer-events: none;
      animation: floatUp 1s ease forwards;
      z-index: 100;
    }
    @keyframes floatUp {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-30px); }
    }
    #overlay input {
      padding: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: none;
      margin-top: 10px;
      width: 200px;
      text-align: center;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      background: #6622cc;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
    }
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 10px #8844ff;
    }
    #lightningButton {
      background: linear-gradient(#ffcc00, #ff9900);
      color: #000;
      font-weight: bold;
    }
    #shieldButton {
      background: linear-gradient(#3399ff, #0066cc);
      font-weight: bold;
    }
    .combo-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 28px;
      font-weight: bold;
      color: gold;
      text-shadow: 0 0 10px #000, 0 0 20px #ff6600;
      opacity: 0;
      transition: all 0.3s;
      pointer-events: none;
      z-index: 1000;
    }
    .combo-show {
      opacity: 1;
      transform: translate(-50%, -60%);
    }
    @keyframes attack {
      0% { transform: translateX(0); }
      25% { transform: translateX(20px); }
      50% { transform: translateX(-20px); }
      100% { transform: translateX(0); }
    }
    .attack-animation {
      animation: attack 0.3s linear;
    }
    #stats {
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 10px;
      margin-top: 10px;
    }
    .ability-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 10px;
    }
  </style>
</head>
<body>
  <h1>üî• –ò–°–ö–†–ê: –ë–∏—Ç–≤–∞ üî•</h1>
  <div id="topBar">
    <div>–í—ã:<br>‚ù§Ô∏è <span id="hp">200</span>/200<br>üõ° <span id="shield">100</span>/100<br>üîÆ <span id="mana">0</span>/100</div>
    <div id="timerBarContainer"><div id="timerBar"></div></div>
    <div>–ú–æ–Ω—Å—Ç—Ä:<br>üíÄ <span id="enemyHp">500</span>/500<br>üõ° <span id="enemyShield">300</span>/300<br>üîÆ <span id="enemyMana">0</span>/100</div>
  </div>
  <div id="battleLog">–°–æ–±–µ—Ä–∏—Ç–µ 3 –∏–ª–∏ –±–æ–ª–µ–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö —à–∞—Ä–∞ –≤ —Ä—è–¥!</div>
  <div id="board"></div>
  <div class="ability-container">
    <button id="lightningButton" onclick="useLightning()">‚ö° –ú–æ–ª–Ω–∏—è (20)</button>
    <button id="shieldButton" onclick="useShield()">üõ° –©–∏—Ç (30)</button>
  </div>
  <div id="overlay">
    <h2>–í–≤–µ–¥–∏—Ç–µ –∏–º—è –≤–æ–∏–Ω–∞:</h2>
    <input id="nickname" placeholder="–í–∞—à–µ –∏–º—è" maxlength="12">
    <button onclick="startGame()">–ù–∞—á–∞—Ç—å –±–∏—Ç–≤—É!</button>
  </div>
  <div id="endScreen" style="display:none;">
    <h2 id="endMessage">–ü–æ–±–µ–¥–∞!</h2>
    <div id="stats">
      –£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span><br>
      –ü–æ–±–µ–¥—ã: <span id="wins">0</span>
    </div>
    <button onclick="startGame()">–°—Ä–∞–∑–∏—Ç—å—Å—è —Å–Ω–æ–≤–∞</button>
  </div>

  <script>
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–≥—Ä—ã
    const CONFIG = {
      colors: ['red', 'green', 'blue', 'purple', 'orange'],
      player: {
        maxHp: 200,
        maxShield: 100,
        maxMana: 100
      },
      monster: {
        maxHp: 500,
        maxShield: 300,
        maxMana: 100
      },
      combo: {
        minMatch: 3,
        damage: [0, 15, 25],
        heal: [0, 8, 15],
        shield: [0, 8, 15],
        mana: [0, 15, 25]
      },
      abilities: {
        lightning: {
          cost: 20,
          damage: 50
        },
        shield: {
          cost: 30,
          amount: 50
        }
      },
      turnTime: 20
    };

    // –≠–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    const elements = {
      board: document.getElementById("board"),
      hp: document.getElementById("hp"),
      shield: document.getElementById("shield"),
      mana: document.getElementById("mana"),
      enemyHp: document.getElementById("enemyHp"),
      enemyShield: document.getElementById("enemyShield"),
      enemyMana: document.getElementById("enemyMana"),
      timerBar: document.getElementById("timerBar"),
      overlay: document.getElementById("overlay"),
      endScreen: document.getElementById("endScreen"),
      endMessage: document.getElementById("endMessage"),
      battleLog: document.getElementById("battleLog"),
      lightningBtn: document.getElementById("lightningButton"),
      shieldBtn: document.getElementById("shieldButton"),
      level: document.getElementById("level"),
      wins: document.getElementById("wins"),
      nickname: document.getElementById("nickname")
    };

    // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    let gameState = {
      grid: [],
      isPlayerTurn: true,
      player: {
        hp: CONFIG.player.maxHp,
        shield: CONFIG.player.maxShield,
        mana: 0
      },
      monster: {
        hp: CONFIG.monster.maxHp,
        shield: CONFIG.monster.maxShield,
        mana: 0
      },
      level: 1,
      wins: 0,
      turnTimer: null,
      combo: {},
      dragging: null,
      lightningUsed: false
    };

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
    function startGame() {
      const nickname = elements.nickname.value || "–í–æ–∏–Ω";
      console.log(`–ù–∞—á–∞–ª–æ –∏–≥—Ä—ã –¥–ª—è: ${nickname}`);
      
      // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è
      gameState = {
        ...gameState,
        isPlayerTurn: true,
        player: {
          hp: CONFIG.player.maxHp,
          shield: CONFIG.player.maxShield,
          mana: 0
        },
        monster: {
          hp: CONFIG.monster.maxHp * (1 + (gameState.level-1)*0.2),
          shield: CONFIG.monster.maxShield * (1 + (gameState.level-1)*0.1),
          mana: 0
        },
        lightningUsed: false
      };
      
      updateUI();
      createGrid();
      elements.overlay.style.display = "none";
      elements.endScreen.style.display = "none";
      document.body.classList.remove("enemy-turn");
      startTurn();
    }

    // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
    function createGrid() {
      elements.board.innerHTML = "";
      gameState.grid = [];
      
      for (let i = 0; i < 36; i++) {
        const cell = document.createElement("div");
        const color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
        cell.className = `cell ${color}`;
        cell.dataset.color = color;
        gameState.grid.push(cell);
        elements.board.appendChild(cell);
      }
    }

    // –ù–∞—á–∞–ª–æ —Ö–æ–¥–∞
    function startTurn() {
      gameState.isPlayerTurn = true;
      gameState.combo = { 
        red: 0, green: 0, blue: 0, orange: 0, purple: 0, 
        count: 0, total: 0 
      };
      gameState.lightningUsed = false;
      document.body.classList.remove("enemy-turn");
      elements.board.style.pointerEvents = "auto";
      updateAbilityButtons();

      let time = CONFIG.turnTime;
      elements.timerBar.style.width = "100%";
      elements.timerBar.style.background = "linear-gradient(90deg, #33ff33, #ffff00)";
      clearInterval(gameState.turnTimer);
      
      gameState.turnTimer = setInterval(() => {
        time--;
        elements.timerBar.style.width = `${(time * 100 / CONFIG.turnTime)}%`;
        
        if (time <= CONFIG.turnTime/3) {
          elements.timerBar.style.background = "linear-gradient(90deg, #ffff00, #ff3333)";
        }
        
        if (time <= 0) {
          clearInterval(gameState.turnTimer);
          elements.board.style.pointerEvents = "none";
          resolveCascade();
        }
      }, 1000);
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Å–∫–∞–¥–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
    function resolveCascade() {
      const matches = findMatches();
      
      if (matches.length === 0) {
        applyComboEffects();
        if (checkGameEnd()) return;
        gameState.isPlayerTurn ? setTimeout(monsterTurn, 1000) : setTimeout(startTurn, 1000);
        return;
      }

      // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
      matches.forEach(group => {
        const color = gameState.grid[group[0]].dataset.color;
        gameState.combo[color] = (gameState.combo[color] || 0) + group.length;
        gameState.combo.count += 1;
        gameState.combo.total += group.length;
        
        group.forEach(idx => {
          gameState.grid[idx].classList.add("highlight");
        });
      });

      setTimeout(() => {
        // –£–¥–∞–ª–µ–Ω–∏–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
        matches.flat().forEach(idx => {
          gameState.grid[idx].classList.add("fade");
        });
        
        setTimeout(() => {
          // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—É—Å—Ç–æ—Ç
          matches.flat().forEach(idx => {
            gameState.grid[idx].className = "cell";
            gameState.grid[idx].dataset.color = "";
          });
          dropCells();
          setTimeout(resolveCascade, 600);
        }, 600);
      }, 1000);
    }

    // –ü–æ–∏—Å–∫ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
    function findMatches() {
      const matches = [];
      const checked = new Set();

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
      for (let row = 0; row < 6; row++) {
        for (let col = 0; col < 4; col++) {
          const idx = row * 6 + col;
          if (checked.has(idx)) continue;
          
          const color = gameState.grid[idx].dataset.color;
          if (!color) continue;
          
          let match = [idx];
          for (let k = 1; col + k < 6; k++) {
            const next = row * 6 + (col + k);
            if (gameState.grid[next].dataset.color === color) {
              match.push(next);
            } else break;
          }
          
          if (match.length >= CONFIG.combo.minMatch) {
            matches.push(match);
            match.forEach(i => checked.add(i));
          }
        }
      }

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
      for (let col = 0; col < 6; col++) {
        for (let row = 0; row < 4; row++) {
          const idx = row * 6 + col;
          if (checked.has(idx)) continue;
          
          const color = gameState.grid[idx].dataset.color;
          if (!color) continue;
          
          let match = [idx];
          for (let k = 1; row + k < 6; k++) {
            const next = (row + k) * 6 + col;
            if (gameState.grid[next].dataset.color === color) {
              match.push(next);
            } else break;
          }
          
          if (match.length >= CONFIG.combo.minMatch) {
            matches.push(match);
            match.forEach(i => checked.add(i));
          }
        }
      }

      return matches;
    }

    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –∫–æ–º–±–æ
    function applyComboEffects() {
      const { red, green, blue, orange, purple, count, total } = gameState.combo;
      
      // –†–∞—Å—á–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
      const effects = {
        damage: red >= 5 ? CONFIG.combo.damage[2] : red >= 3 ? CONFIG.combo.damage[1] : 0,
        heal: green >= 5 ? CONFIG.combo.heal[2] : green >= 3 ? CONFIG.combo.heal[1] : 0,
        shield: blue >= 5 ? CONFIG.combo.shield[2] : blue >= 3 ? CONFIG.combo.shield[1] : 0,
        mana: purple >= 5 ? CONFIG.combo.mana[2] : purple >= 3 ? CONFIG.combo.mana[1] : 0,
        critChance: orange * 2
      };

      // –ü–æ–∫–∞–∑ –∫–æ–º–±–æ
      if (count > 0) showCombo(count, total);

      if (gameState.isPlayerTurn) {
        // –≠—Ñ—Ñ–µ–∫—Ç—ã –¥–ª—è –∏–≥—Ä–æ–∫–∞
        gameState.player.mana += effects.mana;
        if (gameState.player.mana > CONFIG.player.maxMana) {
          gameState.player.mana = CONFIG.player.maxMana;
        }

        const isCrit = Math.random() * 100 < effects.critChance;
        let damage = effects.damage * (isCrit ? 2 : 1);
        
        if (gameState.lightningUsed) {
          damage += CONFIG.abilities.lightning.damage;
        }

        // –ê–Ω–∏–º–∞—Ü–∏—è –∞—Ç–∞–∫–∏
        animateAttack(elements.enemyHp.parentElement, true);
        
        // –ù–∞–Ω–µ—Å–µ–Ω–∏–µ —É—Ä–æ–Ω–∞
        applyDamage(damage, false);
        
        // –õ–µ—á–µ–Ω–∏–µ –∏ –∑–∞—â–∏—Ç–∞
        if (effects.heal > 0) {
          gameState.player.hp += effects.heal;
          if (gameState.player.hp > CONFIG.player.maxHp) {
            gameState.player.hp = CONFIG.player.maxHp;
          }
          showFloatText(`+${effects.heal}`, elements.hp, "#00ff00");
        }
        
        if (effects.shield > 0) {
          gameState.player.shield += effects.shield;
          if (gameState.player.shield > CONFIG.player.maxShield) {
            gameState.player.shield = CONFIG.player.maxShield;
          }
          showFloatText(`+${effects.shield}`, elements.shield, "#3399ff");
        }

        // –õ–æ–≥ –±–∏—Ç–≤—ã
        let log = `<span style="color:#66ff66">–ö–æ–º–±–æ √ó${count} (${total}): `;
        if (effects.damage > 0) log += `–£—Ä–æ–Ω: ${effects.damage}${isCrit ? ' (–ö–†–ò–¢!)' : ''}`;
        if (gameState.lightningUsed) log += ` +${CONFIG.abilities.lightning.damage} –æ—Ç –º–æ–ª–Ω–∏–∏`;
        if (effects.heal > 0) log += `, –õ–µ—á–µ–Ω–∏–µ: +${effects.heal}`;
        if (effects.shield > 0) log += `, –©–∏—Ç: +${effects.shield}`;
        if (effects.mana > 0) log += `, –ú–∞–Ω–∞: +${effects.mana}`;
        elements.battleLog.innerHTML = log + "</span>";

      } else {
        // –≠—Ñ—Ñ–µ–∫—Ç—ã –¥–ª—è –º–æ–Ω—Å—Ç—Ä–∞
        gameState.monster.mana += effects.mana;
        if (gameState.monster.mana > CONFIG.monster.maxMana) {
          gameState.monster.mana = CONFIG.monster.maxMana;
        }

        const isCrit = Math.random() * 100 < effects.critChance;
        const damage = effects.damage * (isCrit ? 2 : 1);

        // –ê–Ω–∏–º–∞—Ü–∏—è –∞—Ç–∞–∫–∏
        animateAttack(elements.hp.parentElement, false);
        
        // –ù–∞–Ω–µ—Å–µ–Ω–∏–µ —É—Ä–æ–Ω–∞
        applyDamage(damage, true);
        
        // –õ–µ—á–µ–Ω–∏–µ –∏ –∑–∞—â–∏—Ç–∞ –º–æ–Ω—Å—Ç—Ä–∞
        if (effects.heal > 0) {
          gameState.monster.hp += effects.heal;
          if (gameState.monster.hp > CONFIG.monster.maxHp * (1 + (gameState.level-1)*0.2)) {
            gameState.monster.hp = CONFIG.monster.maxHp * (1 + (gameState.level-1)*0.2);
          }
          showFloatText(`+${effects.heal}`, elements.enemyHp, "#00ff00");
        }
        
        if (effects.shield > 0) {
          gameState.monster.shield += effects.shield;
          if (gameState.monster.shield > CONFIG.monster.maxShield * (1 + (gameState.level-1)*0.1)) {
            gameState.monster.shield = CONFIG.monster.maxShield * (1 + (gameState.level-1)*0.1);
          }
          showFloatText(`+${effects.shield}`, elements.enemyShield, "#3399ff");
        }

        // –õ–æ–≥ –±–∏—Ç–≤—ã
        elements.battleLog.innerHTML = `<span style="color:#ff4444">–ö–æ–º–±–æ –º–æ–Ω—Å—Ç—Ä–∞ √ó${count}: –£—Ä–æ–Ω: ${effects.damage}${isCrit ? ' (–ö–†–ò–¢!)' : ''}${effects.heal > 0 ? ', –õ–µ—á–µ–Ω–∏–µ: +' + effects.heal : ''}${effects.shield > 0 ? ', –©–∏—Ç: +' + effects.shield : ''}</span>`;
      }

      updateUI();
      checkGameEnd();
    }

    // –ù–∞–Ω–µ—Å–µ–Ω–∏–µ —É—Ä–æ–Ω–∞
    function applyDamage(damage, toPlayer) {
      if (toPlayer) {
        const halfDamage = Math.floor(damage / 2);
        
        if (gameState.player.shield >= halfDamage) {
          gameState.player.shield -= halfDamage;
          gameState.player.hp -= (damage - halfDamage);
        } else {
          const remainingDamage = halfDamage - gameState.player.shield;
          gameState.player.shield = 0;
          gameState.player.hp -= (damage - halfDamage + remainingDamage);
        }
        
        showFloatText(`-${damage}`, elements.hp, "#ff0000");
      } else {
        const halfDamage = Math.floor(damage / 2);
        
        if (gameState.monster.shield >= halfDamage) {
          gameState.monster.shield -= halfDamage;
          gameState.monster.hp -= (damage - halfDamage);
        } else {
          const remainingDamage = halfDamage - gameState.monster.shield;
          gameState.monster.shield = 0;
          gameState.monster.hp -= (damage - halfDamage + remainingDamage);
        }
        
        showFloatText(`-${damage}`, elements.enemyHp, "#ff0000");
      }
    }

    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–æ–ª–Ω–∏–∏
    function useLightning() {
      if (gameState.player.mana >= CONFIG.abilities.lightning.cost && 
          gameState.isPlayerTurn && 
          !gameState.lightningUsed) {
        gameState.player.mana -= CONFIG.abilities.lightning.cost;
        gameState.lightningUsed = true;
        updateUI();
        elements.battleLog.innerHTML += `<br><span style="color:#ffff00">‚ö° –ú–æ–ª–Ω–∏—è –≥–æ—Ç–æ–≤–∞ –∫ —É–¥–∞—Ä—É!</span>`;
      }
    }

    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —â–∏—Ç–∞
    function useShield() {
      if (gameState.player.mana >= CONFIG.abilities.shield.cost && gameState.isPlayerTurn) {
        gameState.player.mana -= CONFIG.abilities.shield.cost;
        gameState.player.shield += CONFIG.abilities.shield.amount;
        if (gameState.player.shield > CONFIG.player.maxShield) {
          gameState.player.shield = CONFIG.player.maxShield;
        }
        updateUI();
        showFloatText(`+${CONFIG.abilities.shield.amount}`, elements.shield, "#3399ff");
        elements.battleLog.innerHTML += `<br><span style="color:#3399ff">üõ° –©–∏—Ç —É—Å–∏–ª–µ–Ω!</span>`;
      }
    }

    // –•–æ–¥ –º–æ–Ω—Å—Ç—Ä–∞
    function monsterTurn() {
      gameState.isPlayerTurn = false;
      document.body.classList.add("enemy-turn");
      updateAbilityButtons();
      
      setTimeout(() => {
        let moved = false;
        
        // –ú–æ–Ω—Å—Ç—Ä –∏—â–µ—Ç –ª—É—á—à–∏–π —Ö–æ–¥
        for (let i = 0; i < 36 && !moved; i++) {
          for (let j = i + 1; j < 36 && !moved; j++) {
            // –ü—Ä–æ–±—É–µ–º –ø–æ–º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏
            [gameState.grid[i].className, gameState.grid[j].className] = 
              [gameState.grid[j].className,
